# Unit Testing

Pembahasan bab ini diambil dari bab 1 dari buku [Software Testing and Quality Assurance - Theory and Practice](https://drive.google.com/file/d/1UBdGl16MTPAFDFITc5Os8M84x9qIf3mI/view?usp=sharing)

> Pengetahuan tidaklah berarti jika Anda menerapkannya dalam praktek - Anton Chekhov

## 3.1 KONSEP _UNIT TESTING_
Dalam bab ini, kami mempertimbangkan pengujian tingkat pertama, yaitu _unit testing_. _Unit testing_ mengacu pada _unit testing_ program secara terpisah. Namun, tidak ada konsensus tentang definisi unit. Beberapa contoh unit yang umum dipahami adalah fungsi, prosedur, atau metode. Bahkan kelas dalam bahasa pemrograman berorientasi objek dapat dianggap sebagai unit program. **Secara sintaksis, unit program adalah bagian kode, seperti fungsi atau metode kelas, yang dipanggil dari luar unit dan dapat memanggil unit program lainnya.** Selain itu, unit program diasumsikan mengimplementasikan fungsi yang terdefinisi dengan baik yang menyediakan tingkat abstraksi tertentu untuk implementasi fungsi tingkat yang lebih tinggi. Fungsi yang dilakukan oleh unit program mungkin tidak memiliki hubungan langsung dengan fungsi tingkat sistem. Dengan demikian, unit program dapat dilihat sebagai bagian kode yang mengimplementasikan fungsi tingkat "rendah". Dalam bab ini, penggunaan  istilah _unit_ dan _modul_ secara bergantian.

Sekarang, mengingat bahwa unit program mengimplementasikan suatu fungsi, wajar saja untuk menguji unit tersebut sebelum diintegrasikan dengan unit lain. Dengan demikian, suatu unit program diuji secara terpisah, yaitu dengan cara yang berdiri sendiri. Ada dua alasan untuk menguji suatu unit secara terpisah. Pertama, kesalahan yang ditemukan selama pengujian dapat dikaitkan dengan unit tertentu sehingga dapat diperbaiki dengan mudah. ​​Selain itu, _unit testing_ menghilangkan ketergantungan pada unit program lainnya. Kedua, selama _unit testing_, sebaiknya verifikasi dilakukan untuk memastikan bahwa setiap eksekusi yang berbeda dari suatu unit program menghasilkan hasil yang diharapkan. Dalam hal detail kode, eksekusi yang berbeda mengacu pada jalur yang berbeda dalam unit tersebut. Idealnya, semua kemungkinan—atau sebanyak mungkin—eksekusi yang berbeda harus dipertimbangkan selama _unit testing_. Hal ini memerlukan pemilihan data input yang cermat untuk setiap eksekusi yang berbeda. Seorang programmer memiliki akses langsung ke vektor input unit dengan mengeksekusi unit program secara terpisah. Akses langsung ini memudahkan eksekusi sebanyak mungkin jalur yang berbeda. Jika beberapa unit disatukan untuk pengujian, maka seorang programmer perlu membuat input pengujian dengan hubungan tidak langsung dengan vektor input dari beberapa unit yang diuji. Hubungan tidak langsung tersebut mempersulit pengendalian eksekusi jalur yang berbeda dalam unit yang dipilih.

_Unit testing_ memiliki cakupan terbatas. Seorang programmer perlu memverifikasi apakah kode berfungsi dengan benar atau tidak dengan melakukan _unit-level testing_. Secara intuitif, seorang programmer perlu menguji unit sebagai berikut:
* Jalankan setiap baris kode. Hal ini diinginkan karena programmer perlu mengetahui apa yang terjadi saat baris kode dieksekusi. Jika tidak ada pengamatan dasar seperti itu, kejutan di tahap selanjutnya bisa jadi mahal.
* Jalankan setiap predikat dalam unit untuk mengevaluasinya menjadi benar dan salah secara terpisah.
* Amati bahwa unit menjalankan fungsi yang dimaksudkan dan pastikan tidak mengandung kesalahan yang diketahui.

Terlepas dari pengujian di atas, tidak ada jaminan bahwa unit yang diuji dengan memuaskan berfungsi dengan benar dari perspektif sistem secara keseluruhan. Tidak semua hal yang berkaitan dengan unit dapat diuji secara terpisah karena keterbatasan pengujian secara terpisah. Ini berarti bahwa beberapa kesalahan dalam unit program hanya dapat ditemukan kemudian, saat unit diintegrasikan dengan unit lain dalam fase pengujian integrasi dan pengujian sistem. Meskipun tidak mungkin menemukan semua kesalahan dalam unit program secara terpisah, tetap penting untuk memastikan bahwa unit tersebut berfungsi dengan memuaskan sebelum digunakan oleh unit program lain. Tidak ada gunanya mengintegrasikan unit yang salah dengan unit lain karena alasan berikut: (i) banyak pengujian berikutnya akan membuang-buang sumber daya dan (ii) menemukan akar penyebab kegagalan dalam sistem yang terintegrasi lebih banyak menghabiskan sumber daya.

**_Unit testing_ dilakukan oleh programmer yang menulis unit program karena programmer sangat mengenal detail internal unit tersebut.** Tujuan programmer adalah untuk merasa yakin bahwa unit tersebut berfungsi seperti yang diharapkan. Karena seorang programmer diharapkan untuk membangun unit tanpa kesalahan di dalamnya, _unit testing_ dilakukan olehnya untuk memuaskannya di awal dan untuk memuaskan programmer lain saat unit tersebut diintegrasikan dengan unit lain. Ini berarti bahwa semua programmer bertanggung jawab atas kualitas pekerjaan mereka sendiri, yang dapat mencakup kode baru dan modifikasi pada kode yang sudah ada. Idenya di sini adalah untuk mendorong konsep kualitas ke tingkat terendah organisasi dan memberdayakan setiap programmer untuk bertanggung jawab atas kualitasnya sendiri. Oleh karena itu, demi kepentingan terbaik programmer untuk mengambil tindakan pencegahan guna meminimalkan jumlah _defect_ dalam kode. _Defect_ yang ditemukan selama _unit testing_ bersifat internal bagi kelompok pengembangan perangkat lunak dan tidak dilaporkan ke hierarki personel untuk dihitung dalam metrik pengukuran kualitas. Kode sumber suatu unit tidak digunakan untuk antarmuka oleh anggota kelompok lain hingga programmer menyelesaikan _unit testing_ dan memeriksa unit tersebut ke sistem kontrol versi.

_Unit testing_ dilakukan dalam dua fase yang saling melengkapi:
* _Unit testing_ statis
* _Unit testing_ dinamis

Dalam _unit testing_ statis, seorang programmer tidak mengeksekusi unit; sebaliknya, kode diperiksa berdasarkan semua kemungkinan perilaku yang mungkin muncul selama run time. _Unit testing_ statis juga dikenal sebagai _unit testing_ berbasis non-eksekusi, sedangkan _unit testing_ dinamis berbasis eksekusi. Dalam _unit testing_ statis, kode setiap unit divalidasi terhadap persyaratan unit dengan meninjau kode. Selama proses peninjauan, masalah potensial diidentifikasi dan diselesaikan. Misalnya, dalam bahasa pemrograman C, dua instruksi penghentian program adalah `abort()` dan `exit()`. Meskipun keduanya terkait erat, keduanya memiliki efek yang berbeda seperti yang dijelaskan di bawah ini:
* `abort()`: Ini berarti penghentian program yang tidak normal. Secara default, panggilan ke `abort()` menghasilkan diagnostik _run time_ dan penghancuran diri program. Penghancuran program mungkin atau mungkin tidak membersihkan dan menutup file yang dibuka atau menghapus file sementara, tergantung pada implementasinya.
* `exit()`: Ini berarti penghentian program yang baik. Artinya, panggilan `exit()` menutup file yang dibuka dan mengembalikan kode status ke lingkungan eksekusi.

Apakah akan menggunakan `abort()` atau `exit()` bergantung pada konteks yang dapat dengan mudah dideteksi dan diselesaikan selama _unit testing_ statis. Semakin banyak masalah yang terdeteksi lebih awal menyebabkan lebih sedikit kesalahan yang diidentifikasi dalam fase pengujian dinamis dan menghasilkan lebih sedikit _defect_ pada produk yang dikirim. Selain itu, melakukan pengujian statis lebih murah daripada melakukan pengujian dinamis. Tinjauan kode merupakan salah satu komponen dari proses minimalisasi _defect_ dan dapat membantu mendeteksi masalah yang umum terjadi pada pengembangan perangkat lunak. Setelah satu putaran tinjauan kode, _unit testing_ dinamis dilakukan. Dalam _unit testing_ dinamis, unit program benar-benar dieksekusi dan hasilnya diamati. _Unit testing_ dinamis berarti menguji kode dengan benar-benar menjalankannya. Perlu dicatat bahwa _unit testing_ statis bukanlah alternatif untuk _unit testing_ dinamis. Seorang programmer melakukan kedua jenis pengujian tersebut. Dalam praktiknya, _unit testing_ dinamis parsial dilakukan bersamaan dengan _unit testing_ statis. Jika seluruh _unit testing_ dinamis telah dilakukan dan _unit testing_ statis mengidentifikasi masalah yang signifikan, _unit testing_ dinamis harus diulang. Sebagai akibat dari pengulangan ini, jadwal pengembangan dapat terpengaruh. Untuk meminimalkan kemungkinan kejadian seperti itu, _unit testing_ statis perlu dilakukan sebelum _unit testing_ dinamis akhir.

### 3.2 PENGUJIAN UNIT STATIS (STATIC UNIT TESTING)
Pengujian unit statis dilakukan sebagai bagian dari keyakinan filosofis yang lebih luas bahwa suatu produk perangkat lunak harus menjalani fase pemeriksaan dan koreksi pada setiap tonggak dalam siklus hidupnya. Pada tonggak tertentu, produk tidak perlu berada dalam bentuk akhirnya. Misalnya, penyelesaian pengodean merupakan tonggak, meskipun pengodean semua unit mungkin tidak menghasilkan produk yang diinginkan. Setelah pengodean, tonggak berikutnya adalah pengujian semua atau sejumlah besar unit yang membentuk komponen utama produk. Jadi, sebelum unit diuji secara individual dengan benar-benar menjalankannya, unit tersebut harus melalui peninjauan dan koreksi seperti yang umum dipahami. Ide di balik peninjauan adalah untuk menemukan cacat sedekat mungkin dengan titik asalnya sehingga cacat tersebut dihilangkan dengan lebih sedikit usaha, dan produk sementara mengandung lebih sedikit cacat sebelum tugas berikutnya dilakukan.

Dalam pengujian unit statis, kode ditinjau dengan menerapkan teknik yang umumnya dikenal sebagai inspeksi dan penelusuran:
* **Inspeksi:** Ini adalah peninjauan kelompok sejawat langkah demi langkah dari suatu produk kerja, dengan setiap langkah diperiksa berdasarkan kriteria yang telah ditentukan sebelumnya.
* **Walkthrough:** Ini adalah tinjauan di mana penulis memandu tim melalui eksekusi produk secara manual atau simulasi menggunakan skenario yang telah ditentukan sebelumnya.

Terlepas dari apakah tinjauan disebut inspeksi atau walkthrough, ini adalah pendekatan sistematis untuk memeriksa kode sumber secara terperinci. Tujuan dari latihan semacam itu adalah untuk menilai kualitas perangkat lunak yang dimaksud, bukan kualitas proses yang digunakan untuk mengembangkan produk [3]. Tinjauan jenis ini dicirikan oleh persiapan yang signifikan oleh kelompok desainer dan programmer dengan berbagai tingkat minat dalam proyek pengembangan perangkat lunak. Pemeriksaan kode dapat memakan waktu. Selain itu, tidak ada proses pemeriksaan yang sempurna. Pemeriksa dapat mengambil jalan pintas, mungkin tidak memiliki pemahaman yang memadai tentang produk, dan mungkin menerima produk yang seharusnya tidak diterima. Meskipun demikian, proses tinjauan kode yang dirancang dengan baik dapat menemukan kesalahan yang mungkin terlewatkan oleh pengujian berbasis eksekusi. Kunci keberhasilan tinjauan kode adalah membagi dan menaklukkan, yaitu, meminta pemeriksa memeriksa bagian-bagian kecil unit secara terpisah, sambil memastikan hal-hal berikut: (i) tidak ada yang terlewatkan dan (ii) kebenaran semua bagian modul yang diperiksa menyiratkan kebenaran seluruh modul. Penguraian tinjauan ke dalam beberapa langkah terpisah harus memastikan bahwa setiap langkah cukup sederhana sehingga dapat dilakukan tanpa pengetahuan terperinci tentang langkah lainnya.

Tujuan dari peninjauan kode adalah untuk meninjau kode, bukan untuk mengevaluasi penulis kode. Bentrokan dapat terjadi antara penulis kode dan peninjau, dan ini dapat membuat rapat menjadi tidak produktif. Oleh karena itu, peninjauan kode harus direncanakan dan dikelola secara profesional. Ada kebutuhan untuk saling menghormati, keterbukaan, kepercayaan, dan berbagi keahlian dalam kelompok. Pedoman umum untuk melakukan peninjauan kode terdiri dari enam langkah seperti yang diuraikan dalam Gambar 3.1: kesiapan, persiapan, pemeriksaan, pengerjaan ulang, validasi, dan keluar. Masukan untuk langkah kesiapan adalah kriteria yang harus dipenuhi sebelum dimulainya proses peninjauan kode, dan proses tersebut menghasilkan dua jenis dokumen, permintaan perubahan/_change request_ (CR) dan laporan. Langkah-langkah dan dokumen ini dijelaskan sebagai berikut.
* **Langkah 1 - Kesiapan (Readiness):** Penulis unit memastikan bahwa unit yang diuji siap untuk ditinjau. Suatu unit dikatakan siap jika memenuhi kriteria berikut:
    * **Kelengkapan (Completeness)**: Semua kode yang berkaitan dengan unit yang akan ditinjau harus tersedia. Hal ini karena para peninjau akan membaca kode tersebut dan mencoba memahaminya. Tidaklah produktif untuk meninjau kode yang ditulis sebagian atau kode yang akan dimodifikasi secara signifikan oleh programmer.\
    ![](images/gambar3.1.PNG)
    * **Fungsionalitas Minimal (Minimal Functionality)**: Kode tersebut harus dikompilasi dan ditautkan. Selain itu, kode tersebut harus telah diuji sampai batas tertentu untuk memastikan bahwa kode tersebut menjalankan fungsi dasarnya.
    * **Keterbacaan (Readability)** : Karena peninjauan kode melibatkan pembacaan kode yang sebenarnya oleh programmer lain, sangat penting bahwa kode tersebut sangat mudah dibaca. Beberapa karakteristik kode yang meningkatkan keterbacaan adalah pemformatan yang tepat, penggunaan nama pengenal yang bermakna, penggunaan konstruksi bahasa pemrograman yang lugas, dan tingkat abstraksi yang sesuai menggunakan pemanggilan fungsi. Jika tidak ada keterbacaan, para peninjau cenderung tidak bersemangat untuk melakukan tugas secara efektif.
    * **Kompleksitas:** Tidak perlu menjadwalkan rapat kelompok untuk meninjau kode langsung yang dapat dengan mudah ditinjau oleh programmer. Kode yang akan ditinjau harus memiliki kompleksitas yang cukup untuk menjamin
    peninjauan kelompok. Di sini, kompleksitas adalah istilah gabungan yang merujuk pada jumlah pernyataan kondisional dalam kode, jumlah elemen data masukan unit, jumlah elemen data keluaran yang dihasilkan oleh unit, pemrosesan kode secara real-time, dan jumlah unit lain yang berkomunikasi dengan kode tersebut.
    * **Persyaratan dan Dokumen Desain (Requirements and Design Documents)**: Versi terbaru yang disetujui dari spesifikasi desain tingkat rendah atau deskripsi persyaratan program lainnya yang sesuai (lihat Tabel 3.1) harus tersedia. Dokumen-dokumen ini membantu para peninjau dalam memverifikasi apakah kode yang sedang ditinjau mengimplementasikan fungsionalitas yang diharapkan atau tidak. Jika dokumen desain tingkat rendah tersedia, dokumen tersebut membantu para peninjau dalam menilai apakah kode tersebut mengimplementasikan desain dengan tepat atau tidak.\
    ![](images/tabel3.1.PNG)

    Semua orang yang terlibat dalam proses peninjauan diberi tahu tentang jadwal rapat peninjauan kelompok dua atau tiga hari sebelum rapat. Mereka juga diberi salinan paket kerja untuk dibaca. Tinjauan dilakukan dalam waktu singkat 1–2 jam. Rapat yang lebih lama kurang produktif karena rentang perhatian manusia yang terbatas. Kecepatan tinjauan kode dibatasi hingga sekitar 125 baris kode (dalam bahasa tingkat tinggi) per jam. Meninjau kode yang rumit dengan kecepatan yang lebih tinggi akan menghasilkan kode yang hanya diabaikan, sehingga mengalahkan tujuan mendasar tinjauan kode. Komposisi kelompok peninjau melibatkan sejumlah orang dengan peran yang berbeda. Peran-peran ini dijelaskan sebagai berikut:
    * **Moderator:** Rapat tinjauan dipimpin oleh moderator. Moderator adalah individu terlatih yang memandu kecepatan proses tinjauan. Moderator memilih peninjau dan menjadwalkan rapat tinjauan. Myers menyarankan agar moderator menjadi anggota kelompok dari proyek yang tidak terkait untuk menjaga objektivitas.
    * **Penulis:** Ini adalah orang yang telah menulis kode yang akan ditinjau.
    * **Presenter:** Presenter adalah seseorang selain penulis kode. Presenter membaca kode terlebih dahulu untuk memahaminya. Presenterlah yang mempresentasikan kode penulis dalam rapat peninjauan karena alasan berikut: (i) pengembang perangkat lunak tambahan akan memahami pekerjaan dalam organisasi perangkat lunak; (ii) jika programmer asli meninggalkan perusahaan dengan pemberitahuan singkat, setidaknya satu programmer lain di perusahaan mengetahui apa yang sedang dilakukan; dan (iii) programmer asli akan merasa senang dengan pekerjaannya, jika orang lain menghargai pekerjaan mereka. Biasanya, presenter menghargai pekerjaan penulis.
    * **Pencatat (Recordkeeper):** Pencatat mendokumentasikan masalah yang ditemukan selama proses peninjauan dan tindakan tindak lanjut yang disarankan. Orang yang ditunjuk harus berbeda dari penulis dan moderator.
    * **Peninjau (Reviewer):** Mereka adalah pakar dalam bidang subjek kode yang sedang ditinjau. Ukuran kelompok bergantung pada konten materi yang sedang ditinjau. Sebagai aturan praktis, ukuran kelompok adalah antara 3 dan 7 orang. Biasanya kelompok ini tidak memiliki manajer yang menjadi bawahan penulis. Ini karena pekerjaan penulis yang sedang ditinjau, dan bukan pekerjaan yang telah selesai maupun penulis sendiri yang sedang ditinjau. * Pengamat: Mereka adalah orang-orang yang ingin mempelajari kode yang sedang ditinjau. Orang-orang ini tidak berpartisipasi dalam proses peninjauan, tetapi hanya menjadi pengamat pasif.

* **Langkah 2 - Persiapan:** Sebelum rapat, setiap peninjau meninjau paket kerja dengan saksama. Diharapkan para peninjau membaca kode dan memahami organisasi serta operasinya sebelum rapat peninjauan. Setiap peninjau mengembangkan hal-hal berikut:
    * **Daftar Pertanyaan:** Seorang peninjau menyiapkan daftar pertanyaan yang akan diajukan, jika diperlukan, kepada penulis untuk mengklarifikasi masalah yang timbul dari hasil pembacaannya. Pedoman umum tentang apa yang harus diperiksa saat membaca kode diuraikan dalam Tabel 3.2.

        | Code Review Checklist |
        | --- |
        | 1. Apakah kode tersebut melakukan apa yang telah ditetapkan dalam spesifikasi desain? |
        | 2. Apakah prosedur yang digunakan dalam modul tersebut memecahkan masalah dengan benar? |
        | 3. Apakah modul perangkat lunak menduplikasi modul lain yang sudah ada yang dapat digunakan kembali? |
        | 4. Jika modul pustaka digunakan, apakah pustaka dan versi pustaka yang tepat digunakan? |
        | 5. Apakah setiap modul memiliki satu titik masuk dan satu titik keluar? Beberapa program titik keluar dan masuk lebih sulit untuk diuji. |
        | 6. Apakah kompleksitas siklomatik modul lebih dari 10? Jika ya, maka sangat sulit untuk menguji modul secara memadai. |
        | 7. Dapatkah setiap fungsi atom ditinjau dan dipahami dalam waktu 10–15 menit? Jika tidak, maka dianggap terlalu rumit. |
        | 8. Apakah konvensi penamaan telah diikuti untuk semua pengenal, seperti pointer, indeks, variabel, array, dan konstanta? Penting  untuk mematuhi standar pengkodean guna memudahkan pengenalan kontributor (programmer) baru untuk pengembangan sistem. |
        | 9. Apakah kode tersebut telah dikomentari secara memadai? 10. Apakah semua variabel dan konstanta telah diinisialisasi dengan  benar? Apakah tipe dan cakupan yang benar telah diperiksa? |
        | 11. Apakah variabel global atau variabel bersama, jika ada, dikontrol dengan saksama? |
        | 12. Apakah ada nilai data yang dikodekan secara permanen dalam program? Sebaliknya, nilai-nilai ini harus dideklarasikan sebagai  variabel. |
        | 13. Apakah pointer digunakan dengan benar? |
        | 14. Apakah blok memori yang diperoleh secara dinamis dihapus setelah digunakan? |
        | 15. Apakah modul berakhir secara tidak normal? Apakah modul akhirnya akan berakhir? |
        | 16. Apakah ada kemungkinan loop tak terbatas, loop yang tidak pernah dijalankan, atau loop dengan keluar prematur? |
        | 17. Apakah semua file telah dibuka untuk digunakan dan ditutup saat berakhir? |
        | 18. Apakah ada perhitungan menggunakan variabel dengan tipe data yang tidak konsisten? Apakah kemungkinan terjadi luapan atau  kekurangan luapan? |
        | 19. Apakah kode kesalahan dan pesan kondisi dihasilkan dengan mengakses tabel pesan umum? Setiap kode kesalahan harus memiliki  makna, dan semua makna harus tersedia di satu tempat dalam tabel, bukan tersebar di seluruh kode program. |
        | 20. Apakah kode tersebut portabel? Kode sumber kemungkinan akan dijalankan pada beberapa arsitektur prosesor dan pada sistem  operasi yang berbeda selama masa pakainya. Kode tersebut harus diimplementasikan dengan cara yang tidak menghalangi berbagai lingkungan eksekusi semacam ini. |
        | 21. Apakah kode tersebut efisien? Secara umum, kejelasan, keterbacaan, atau kebenaran tidak boleh dikorbankan demi efisiensi.  Tinjauan kode dimaksudkan untuk mendeteksi pilihan implementasi yang berdampak buruk pada kinerja sistem. |\
        **Tabel 3.2 Code Review Checklist**
    
    * **Potensi CR:** Seorang peninjau dapat mengajukan permintaan formal untuk melakukan perubahan. Ini disebut permintaan perubahan, bukan laporan cacat. Pada tahap ini, karena programmer belum mempublikasikan kode, lebih tepat untuk memberikan saran kepada penulis untuk melakukan perubahan, daripada melaporkan cacat. Meskipun CR berfokus pada cacat dalam kode, laporan ini tidak termasuk dalam statistik cacat yang terkait dengan produk.
    * **Peluang Peningkatan yang Disarankan:** Peninjau dapat menyarankan cara memperbaiki masalah, jika ada, dalam kode yang sedang ditinjau. Karena peninjau merupakan pakar di bidang subjek kode, bukan hal yang aneh bagi mereka untuk memberikan saran perbaikan.

* **Langkah 3: Pemeriksaan:** Proses pemeriksaan terdiri dari aktivitas berikut:
    * Penulis membuat presentasi tentang logika prosedural yang digunakan dalam kode, jalur yang menunjukkan komputasi utama, dan ketergantungan unit yang ditinjau pada unit lain.
    * Penyaji membaca kode baris demi baris. Peninjau dapat mengajukan pertanyaan jika kode tersebut dianggap memiliki cacat. Namun, masalah tidak terselesaikan dalam rapat. Peninjau dapat memberikan saran umum tentang cara memperbaiki cacat, tetapi terserah kepada penulis kode untuk mengambil tindakan perbaikan setelah rapat berakhir.
    * Pencatat mendokumentasikan permintaan perubahan dan saran untuk memperbaiki masalah, jika ada. CR mencakup detail berikut:
        1. Berikan deskripsi singkat tentang masalah atau tindakan.
        2. Tetapkan tingkat prioritas (utama atau minor) untuk CR.
        3. Tetapkan seseorang untuk menindaklanjuti masalah tersebut. Karena CR mendokumentasikan potensi masalah, diperlukan interaksi antara penulis kode dan salah satu peninjau, mungkin peninjau yang membuat CR.
        4. Tetapkan tenggat waktu untuk menangani CR

    * Moderator memastikan bahwa rapat tetap fokus pada proses peninjauan. Moderator memastikan bahwa rapat berjalan dengan kecepatan tertentu sehingga tujuan rapat tercapai.
    * Di akhir rapat, keputusan diambil mengenai apakah akan mengadakan rapat lain untuk meninjau kode lebih lanjut atau tidak. Jika proses peninjauan mengarah pada pengerjaan ulang kode secara ekstensif atau masalah kritis diidentifikasi dalam proses tersebut, maka rapat lain biasanya diadakan. Jika tidak, rapat kedua tidak dijadwalkan, dan penulis diberi tanggung jawab untuk memperbaiki CR.

* **Langkah 4: Pengerjaan Ulang:** Di akhir rapat, pencatat membuat ringkasan rapat yang mencakup informasi berikut:
    * Daftar semua CR, tanggal perbaikannya, dan nama orang yang bertanggung jawab untuk memvalidasi CR
    * Daftar peluang perbaikan
    * Risalah rapat (opsional)

    Salinan laporan dibagikan kepada semua anggota kelompok peninjau. Setelah pertemuan, penulis mengerjakan CR untuk memperbaiki masalah. Penulis mendokumentasikan perbaikan yang dilakukan pada kode dalam CR. Penulis berupaya mengatasi masalah dalam jangka waktu yang disepakati dengan menggunakan konvensi pengkodean yang berlaku.

* **Langkah 5 - Validasi:** CR divalidasi secara independen oleh moderator atau orang lain yang ditunjuk untuk tujuan ini. Proses validasi melibatkan pengecekan kode yang dimodifikasi sebagaimana didokumentasikan dalam CR dan memastikan bahwa perbaikan yang disarankan telah diterapkan dengan benar. Versi revisi dan final dari hasil rapat tinjauan didistribusikan ke semua anggota kelompok.

* **Langkah 6: Keluar:** Merangkum proses tinjauan, dikatakan selesai jika semua tindakan berikut telah diambil:
    * Setiap baris kode dalam unit telah diperiksa.
    * Jika terlalu banyak cacat ditemukan dalam suatu modul, modul tersebut sekali lagi ditinjau setelah koreksi diterapkan oleh penulis. Sebagai aturan praktis, jika lebih dari 5% dari total baris kode dianggap kontroversial, maka tinjauan kedua dijadwalkan.
    * Penulis dan peninjau mencapai konsensus bahwa ketika koreksi telah diterapkan, kode tersebut berpotensi bebas dari cacat.
    * Semua CR didokumentasikan dan divalidasi oleh moderator atau orang lain. Tindakan tindak lanjut penulis didokumentasikan.
    * Laporan ringkasan rapat termasuk CR didistribusikan ke semua anggota kelompok peninjau.

Efektivitas pengujian statis dibatasi oleh kemampuan peninjau untuk menemukan cacat dalam kode melalui cara visual. Namun, jika kemunculan cacat bergantung pada beberapa nilai variabel aktual, maka merupakan tugas yang sulit untuk mengidentifikasi cacat tersebut melalui cara visual. Oleh karena itu, suatu unit harus dijalankan untuk mengamati perilakunya sebagai respons terhadap berbagai masukan. Akhirnya, apa pun efektivitas pengujian statis, seseorang tidak dapat merasa yakin tanpa benar-benar menjalankan kode.

**Metrik Peninjauan Kode Penting (Code Review Metrics)** untuk mengumpulkan data pengukuran yang berkaitan dengan proses peninjauan, sehingga proses peninjauan dapat dievaluasi, dibuat terlihat oleh manajemen atas sebagai strategi pengujian, dan ditingkatkan agar lebih efektif. Selain itu, pengumpulan metrik selama peninjauan kode memfasilitasi estimasi waktu dan sumber daya peninjauan untuk proyek mendatang. Dengan demikian, peninjauan kode merupakan strategi pengujian yang layak yang dapat digunakan secara efektif untuk meningkatkan kualitas produk pada tahap awal. Metrik berikut dapat dikumpulkan dari tinjauan kode:
* Jumlah baris kode/_Line of Code_ (LOC) yang ditinjau per jam
* Jumlah CR yang dihasilkan per seribu baris kode (KLOC)
* Jumlah CR yang dihasilkan per jam
* Jumlah total CR yang dihasilkan per proyek
* Jumlah total jam yang dihabiskan untuk tinjauan kode per proyek

## 3.3 PENGUJIAN UNIT DINAMIS (DYNAMIC UNIT TESTING)
Pengujian unit berbasis eksekusi disebut sebagai pengujian unit dinamis. Dalam pengujian ini, unit program sebenarnya dieksekusi secara terpisah, seperti yang umum kita pahami. Namun, eksekusi ini berbeda dari eksekusi biasa dengan cara berikut:
1. Unit yang diuji dikeluarkan dari lingkungan eksekusi aktualnya.
2. Lingkungan eksekusi aktual diemulasi dengan menulis lebih banyak kode (dijelaskan nanti di bagian ini) sehingga unit dan lingkungan yang diemulasi dapat dikompilasi bersama.
3. Agregat yang dikompilasi di atas dieksekusi dengan input yang dipilih. Hasil dari eksekusi tersebut dikumpulkan dengan berbagai cara, seperti pengamatan langsung di layar, pencatatan pada file, dan instrumentasi perangkat lunak kode untuk mengungkap perilaku waktu proses. Hasilnya dibandingkan dengan hasil yang diharapkan. Setiap perbedaan antara hasil aktual dan yang diharapkan menyiratkan kegagalan dan kesalahan ada pada kode.

Lingkungan untuk pengujian unit dinamis dibuat dengan mengemulasi konteks unit yang diuji, seperti yang ditunjukkan pada Gambar 3.2. Konteks pengujian unit terdiri dari dua bagian: (i) pemanggil unit dan (ii) semua unit yang dipanggil oleh unit tersebut. Lingkungan unit diemulasikan karena unit tersebut akan diuji secara terpisah dan lingkungan emulasi harus sederhana sehingga setiap kesalahan yang ditemukan sebagai hasil dari menjalankan unit dapat semata-mata dikaitkan dengan unit yang diuji. Unit pemanggil dikenal sebagai driver pengujian, dan semua emulasi unit yang dipanggil oleh unit yang diuji disebut stub. Driver pengujian dan stub secara bersama-sama disebut scaffolding. Fungsi driver pengujian dan stub dijelaskan sebagai berikut:
    * **Driver Pengujian (Test Driver):** Driver pengujian adalah program yang memanggil unit yang diuji. Unit yang diuji dijalankan dengan nilai input yang diterima dari driver dan, setelah selesai, mengembalikan nilai ke driver. Driver membandingkan hasil aktual, yaitu, nilai aktual yang dikembalikan oleh unit yang diuji, dengan hasil yang diharapkan dari unit dan melaporkan hasil pengujian berikutnya. Driver pengujian berfungsi sebagai unit utama dalam proses eksekusi. Driver tidak hanya memfasilitasi kompilasi, tetapi juga menyediakan data input ke unit yang diuji dalam format yang diharapkan.
    * **Stub:** Stub adalah "subprogram tiruan" yang menggantikan unit yang dipanggil oleh unit yang diuji. Stub menggantikan unit yang dipanggil oleh unit yang diuji. Stub melakukan dua tugas. Pertama, stub menunjukkan bukti bahwa stub memang dipanggil. Bukti tersebut dapat ditunjukkan hanya dengan mencetak pesan. Kedua, stub mengembalikan nilai yang telah dihitung sebelumnya ke pemanggil sehingga unit yang diuji dapat melanjutkan eksekusinya.

![](images/gambar3.2.PNG)

Driver dan stub tidak pernah dibuang setelah pengujian unit selesai. Sebaliknya, keduanya digunakan kembali di masa mendatang dalam pengujian regresi unit jika diperlukan. Untuk setiap unit, harus ada satu driver pengujian khusus dan beberapa stub sesuai kebutuhan. Jika hanya satu driver pengujian yang dikembangkan untuk menguji beberapa unit, driver tersebut akan menjadi rumit. Setiap modifikasi pada driver untuk mengakomodasi perubahan pada salah satu unit yang diuji dapat memiliki efek samping dalam pengujian unit lainnya. Demikian pula, driver pengujian tidak boleh bergantung pada berkas data masukan eksternal, tetapi sebaliknya, harus memiliki kumpulan data masukannya sendiri yang terpisah. Pendekatan berkas data masukan terpisah menjadi pilihan yang sangat menarik untuk sejumlah besar data masukan pengujian. Misalnya, jika ratusan elemen data masukan pengujian diperlukan untuk menguji lebih dari satu unit, maka lebih baik membuat berkas data masukan pengujian terpisah daripada menyertakan kumpulan data masukan pengujian yang sama di setiap driver pengujian yang dirancang untuk menguji unit tersebut.

Driver pengujian harus memiliki kemampuan untuk secara otomatis menentukan keberhasilan atau kegagalan unit yang diuji untuk setiap data masukan pengujian. Jika sesuai, driver juga harus memeriksa kebocoran memori dan masalah dalam alokasi dan dealokasi memori. Jika modul membuka dan menutup berkas, driver pengujian harus memeriksa apakah berkas-berkas ini dibiarkan dalam keadaan terbuka atau tertutup yang diharapkan setelah setiap pengujian. Driver pengujian dapat dirancang untuk memeriksa nilai data variabel internal yang biasanya tidak tersedia untuk diperiksa pada tingkat pengujian integrasi, sistem, atau penerimaan.

Driver pengujian dan stub dipasangkan erat dengan unit yang diuji dan harus menyertai unit tersebut sepanjang siklus hidupnya. Driver uji dan stub untuk suatu unit harus dapat digunakan kembali dan dirawat. Setiap kali suatu unit dimodifikasi, programmer harus memeriksa apakah akan memodifikasi driver dan stub yang sesuai atau tidak. Setiap kali kesalahan baru terdeteksi pada unit tersebut, driver uji yang sesuai harus diperbarui dengan serangkaian data masukan baru untuk mendeteksi kesalahan tersebut dan kesalahan serupa di masa mendatang. Jika unit tersebut diharapkan berjalan pada platform yang berbeda, driver uji dan stub juga harus dibuat untuk menguji unit tersebut pada platform baru. Terakhir, driver uji dan stub harus ditinjau ulang, direferensikan silang dengan unit yang ditulisinya, dan